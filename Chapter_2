import math
import numpy as np
import array

# normal array
li = list(range(10))
#A = array.array('i', li)
#print('A =', A) 

# numpy array, better for operations
#B = np.array([3.14,4,2,3]) #FIXED TYPE
#print('B =', B)

#C = np.array([1,2,3,4], dtype='float32') #can explicitly set type
#print('C =', C)

#D = np.array([range(i,i+3) for i in [2,4,6]]) #nested lists -> multidimensional arrays
#print('D =', D)

#Creating useful arrays

#E = np.zeros(10, dtype=int) # array of 10 zeros (int)
#print('E =', E)

#F = np.ones((3,5),dtype=float) # 3x5 array of ones (float)
#print('F =', F)

#G = np.full((3,5), 3.14) # 3x5 array, each entry = pi
#print('G =', G)

#H = np.arange(0,5,.5) #array [0,5), step size .5
#print('H =', H)

#I = np.linspace(0,1,5) #array [0,1], five values in array
#print('I =', I)

#J = np.random.random((3,3)) # 3x3 array of random values (unif dist) between 0 and 1
#print('J =', J)

#K = np.random.normal(0,1,(3,3)) #3x3 array of random values (normal dist, mean 0, stand dev 1) 
#print('K =', K)

#L = np.random.randint(0,10,(3,3)) # 3x3 array of random ints (unif dist) between 0 and 10
#print('L =', L)

#M = np.eye(3) # 3x3 identity matrix (float?)
#print('M =', M)

#N = np.empty(3) # array of length 3, uninitialized (starting values whatever is already at the memory location)
#print('N =', N)

#Array attributes

np.random.seed(0) #seed to get same random values each time

x1 = np.random.randint(10, size = 6)       # 1D array
x2 = np.random.randint(10, size = (3,4))   # 2D array
x3 = np.random.randint(10, size = (3,4,5)) # 3D array

#print(x3)

print('x3 ndim: ', x3.ndim)   # number of dimensions in x3
print('x3 shape: ', x3.shape) # size of each dimension
print('x3 size: ', x3.size)   # total number of elements in x3
print('x3 dtype: ', x3.dtype) # data type
print('itemsize: ', x3.itemsize, 'bytes') # size of each element (bytes)
print('nbytes: ', x3.nbytes, 'bytes')     # size of array (bytes)

# Accessing elements

a = x1[0]
b = x1[4]
c = x1[-2] # should be the same as b

d = x2[0,0]

e = x1[1:4] #elements 1 thru 3

f = x1[1::2] #every other element, starting at 1

g = x1[::-1] #all elements reversed

# Multidimensional arrays: similar, separate each dimension with commas

h = x2[:2, ::2] #first two rows, every other column starting at 0

i = x2[:,2] #full third column
j = x2[1,:] #full first row

# creating copies

x2_subcopy = x2[:2,:2].copy() # creates a copy of the subarray, not a view

#reshaping arrays 
# sizes (number of elements in array) MUST MATCH

grid = np.arange(1,10).reshape((3,3))
print(grid)

# convert 1D array into 2D row/column matrix

y = np.array([1,2,3])

y1 = y.reshape((1,3)) #row vector via reshape
y2 = y[np.newaxis,:]  #row vector via newaxis, same as y1

y3 = y.reshape((3,1)) #col vector via reshape
y4 = y[:,np.newaxis]  #col vector via newaxis, same as y3

# Concatenation

z = np.array([[1,2,3],[4,5,6]])

z2 = np.concatenate([z,z]) #concatenate vertically (dimension 1)
z3 = np.concatenate([z,z], axis=1) #concatenate horizontally (dimension 2)

x = np.array([[9],[8]])

# for mixed dimensions, clearer to use horizontal/vertical stack

p = np.vstack([y,z]) #vertically stacking y and z
q = np.hstack([z,x]) #horizontally stacking z and x
# use np.dstack for third axis


